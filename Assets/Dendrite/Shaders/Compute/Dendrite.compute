#pragma kernel Setup
#pragma kernel Start
#pragma kernel Search
#pragma kernel Grow
#pragma kernel Attract
#pragma kernel Connect
#pragma kernel Remove

#define THREAD_1D [numthreads(128, 1, 1)]

#include "Assets/Common/Shaders/Random.hlsl"

#include "../Common/Attraction.hlsl"
#include "../Common/Node.hlsl"
#include "../Common/Edge.hlsl"
#include "../Common/Candidate.hlsl"

StructuredBuffer<float3> _Start;
RWStructuredBuffer<Attraction> _Attractions;

AppendStructuredBuffer<uint> _NodesPoolAppend;
ConsumeStructuredBuffer<uint> _NodesPoolConsume;
RWStructuredBuffer<Node> _Nodes;

AppendStructuredBuffer<Candidate> _CandidatesPoolAppend;
ConsumeStructuredBuffer<Candidate> _CandidatesPoolConsume;
uint _ConnectCount;

AppendStructuredBuffer<Edge> _EdgesPoolAppend;

float _DT;

float _InfluenceDistance, _GrowthDistance, _KillDistance;

uint CreateNode(out Node node)
{
  uint i = _NodesPoolConsume.Consume();
  node.position = float3(0, 0, 0);
  node.t = 0;
  node.offset = 0;
  node.mass = 0;
  node.from = -1;
  node.active = true;
  return i;
}

void CreateEdge(int a, int b)
{
  Edge e;
  e.a = a;
  e.b = b;
  _EdgesPoolAppend.Append(e);
}

THREAD_1D
void Setup (uint3 id : SV_DispatchThreadID)
{
  uint idx = id.x;
  uint count, stride;
  _Nodes.GetDimensions(count, stride);
  if (idx >= count)
    return;

  _NodesPoolAppend.Append(idx);

  Node n = _Nodes[idx];
  n.active = false;
  n.t = 0;
  _Nodes[idx] = n;
}

THREAD_1D
void Start (uint3 id : SV_DispatchThreadID)
{
  uint idx = id.x;

  uint count, stride;
  _Start.GetDimensions(count, stride);
  if (idx >= count)
    return;

  Node n;
  uint i = CreateNode(n);
  n.position = _Start[idx];
  n.t = 1;
  n.offset = 0;
  n.from = -1;
  n.mass = nrand(id.xy);
  _Nodes[i] = n;
}

THREAD_1D
void Search (uint3 id : SV_DispatchThreadID)
{
  uint idx = id.x;
  uint count, stride;
  _Attractions.GetDimensions(count, stride);
  if (idx >= count)
    return;

  Attraction attr = _Attractions[idx];
  attr.found = false;
  if (attr.active)
  {
    _Nodes.GetDimensions(count, stride);

    float min_dist = _InfluenceDistance;
    uint nearest = -1;

    for (uint i = 0; i < count; i++)
    {
      Node n = _Nodes[i];
      if (n.active)
      {
        float d = distance(n.position, attr.position);
        if (d < min_dist)
        {
          min_dist = d;
          nearest = i;
          attr.found = true;
        }
      }
    }

    attr.nearest = nearest;
    _Attractions[idx] = attr;
  }

}

THREAD_1D
void Grow (uint3 id : SV_DispatchThreadID)
{
  uint idx = id.x;
  uint count, stride;
  _Nodes.GetDimensions(count, stride);
  if (idx >= count)
    return;

  Node n = _Nodes[idx];
  if (n.active)
  {
    n.t = saturate(n.t + _DT * n.mass);
    _Nodes[idx] = n;
  }
}


THREAD_1D
void Attract (uint3 id : SV_DispatchThreadID)
{
  uint idx = id.x;
  uint count, stride;
  _Nodes.GetDimensions(count, stride);
  if (idx >= count)
    return;

  Node n = _Nodes[idx];
  if (n.active && n.t >= 1.0)
  {
    float3 dir = (0.0).xxx;
    uint counter = 0;

    // search neighbors in radius
    _Attractions.GetDimensions(count, stride);
    for (uint i = 0; i < count; i++)
    {
      Attraction attr = _Attractions[i];
      if (attr.active && attr.found && attr.nearest == idx)
      {
        float3 dir2 = (attr.position - n.position);
        dir += normalize(dir2);
        counter++;
      }
    }

    if (counter > 0)
    {
      Candidate c;
      dir = dir / counter;
      c.position = n.position + (dir * _GrowthDistance);
      c.index = idx;
      _CandidatesPoolAppend.Append(c);
    }
  }
}

THREAD_1D
void Connect (uint3 id : SV_DispatchThreadID)
{
  uint idx = id.x;
  if (idx >= _ConnectCount)
    return;

  Candidate c = _CandidatesPoolConsume.Consume();
  Node n2;
  uint idx2 = CreateNode(n2);
  n2.position = c.position;
  n2.offset = _Nodes[c.index].offset + 1.0;
  n2.mass = nrand(float2(c.index, idx2));
  n2.from = c.index;
  _Nodes[idx2] = n2;
  CreateEdge(c.index, idx2);
}

THREAD_1D
void Remove (uint3 id : SV_DispatchThreadID)
{
  uint idx = id.x;
  uint count, stride;
  _Nodes.GetDimensions(count, stride);
  if (idx >= count)
    return;

  Node n = _Nodes[idx];
  if (!n.active)
    return;

  _Attractions.GetDimensions(count, stride);
  for (uint i = 0; i < count; i++)
  {
    Attraction attr = _Attractions[i];
    if (attr.active)
    {
      float d = distance(attr.position, n.position);
      if (d < _KillDistance)
      {
        attr.active = false;
        _Attractions[i] = attr;
      }
    }
  }

}

